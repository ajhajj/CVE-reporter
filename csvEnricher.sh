#!/bin/bash

# The source (CSV) spreadsheet
INPUT_FILE=twistlock.csv

# The filename for our output
OUTPUT_FILE=output.csv

# Text delimiter for parsing CSV
DEL=","

# Column name that lists the CVE IDs in your (CSV) spreadsheet
CVE_ID="CVE ID"

# Base URL for the Red Hat Data Security API
RESTURL=https://access.redhat.com/hydra/rest/securitydata/cve/

# Base URL for the Red Hat CVE Database CVE detail page
RHCVEDBURL=https://access.redhat.com/security/cve/

# Working folder to store JSON files returned by the API
JSON_FLDR=JSON

CWD=$(pwd)
PLACEHOLDER="REDHAT_BLANK_PLACEHOLDER"

echo "Updating CSV document..."
rm -f ${OUTPUT_FILE}

echo "Extracting CVE list from CSV..."
index=`awk -F "${DEL}" 'NR>1{exit}1{ for (i=1;i<=NF;i++) if ($i == "'"${CVE_ID}"'") print i }' ${INPUT_FILE}`
awk -v pos=${index} -v OFS="${DEL}" -F "${DEL}" '$pos == "" { $pos = "'"${PLACEHOLDER}"'"}1' ${INPUT_FILE} >${OUTPUT_FILE}
CVEARR=($(awk -v pos=${index} -F "${DEL}" 'NR>1{print $pos}' ${OUTPUT_FILE}))
UNQ_CVEARR=($(echo "${CVEARR[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

# fix for CVE IDs showing up in wrong columns in twistlock report
sed -i -e 's/,CVE\(-[0-9]*-[0-9]*,CVE-[0-9]*-[0-9]*,\)/,cve\1/' ${OUTPUT_FILE}

#rm -rf ${JSON_FLDR}
#mkdir ${JSON_FLDR}
#cd ${JSON_FLDR}

#echo "Retrieving Red Hat data on CVEs..."
#for cve in "${UNQ_CVEARR[@]}"; 
#  do
#    wget -q -nc ${RESTURL}${cve}.json
#  done

# Return to starting folder
cd ${CWD}

# Add column headers for data we will inject
sed -i -e 's/'"${CVE_ID}"'/'"${CVE_ID}"',RH_CSSV_SCORE,RH_CSSV_VECTOR,RH_CSSV_STATUS,RH_STATEMENT,RH_CVE_DB_LINK/' ${OUTPUT_FILE}

for cve in "${UNQ_CVEARR[@]}";  
  do
    cvss_base_score=""
    cvss_scoring_vector=""
    status=""
    statement=""
    rhcvedb=""

    # CSV may not exist in RH Database
    if [ -f "${JSON_FLDR}/${cve}.json" ]; then
      cvss3=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss3'`

      # cvss may not be populated as version 3.x
      if [ "${cvss3}" == "null" ]; then
        cvss_base_score=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss.cvss_base_score'`
        cvss_scoring_vector=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss.cvss_scoring_vector'`
        status=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss.status'`
      else
        cvss_base_score=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss3.cvss3_base_score'`
        cvss_scoring_vector=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss3.cvss3_scoring_vector'`
        status=`cat ${JSON_FLDR}/${cve}.json | jq -r '.cvss3.status'`
      fi

      # statement field can contain newline characters
      # removing newlines for simplification of sed logic
      statement=$(cat ${JSON_FLDR}/${cve}.json | jq -r '.statement' | tr '\n' ' ' | sed -e "s/\"/'/g")

      if [ "${statement}" == "null " ]; then
        statement=""
      else
        statement="\"${statement}\""
      fi

      if [[ ${cve} == CVE-* ]]; then
        # Red Hat CVE detail link
        rhcvedb="=HYPERLINK(\"${RHCVEDBURL}${cve}\")"
      fi

    elif [ "${cve}" == "${PLACEHOLDER}" ]; then
      echo "CVE not specified."
    else
      echo "CVE \"${cve}\" not resolved."
    fi

    # concatonating our fields (comma delimited)
    # Note that statement can contain commas, so encapsulating content in double quotes
    data=",${cvss_base_score},${cvss_scoring_vector},${status},${statement},${rhcvedb}"
    sed -i -e 's|,'"${cve}"',|,'"${cve}${data}"',|' ${OUTPUT_FILE}

  done

# remove the positional placeholder inserted earlier
sed -i -e 's/,'"${PLACEHOLDER}"',/,,/g' ${OUTPUT_FILE}
